# -*- coding: utf-8 -*-
"""Another copy of Uberhacks.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10YDHXlFB8HVNyUAWeFdvU88L72Zl-Hxo
"""

import matplotlib.pyplot as plt
import math
import seaborn as sns
from IPython.display import clear_output
from random import randint, choice, random
import numpy as np

class RoadGrid():

    def __init__(self, numRoads, maxCars):

        self.numRoads = numRoads
        self.maxCars = maxCars
        self.lanes = 2
        self.N = self.numRoads * self.lanes * 2 + (self.numRoads + 1) * self.maxCars

        self.v_lanes = []
        for i in range(self.N):
            i = i % (self.maxCars + self.lanes * 2)
            if (i < self.maxCars): self.v_lanes.append(0)
            else: self.v_lanes.append(i - self.maxCars + 1)

        self.h_lanes = self.v_lanes

        self.grid = self.createMatrix(maxCars, self.lanes, numRoads)
        self.signal_grid = self.createSignalMatrix()

    def createMatrix(self, maxCars, lanes, roads):

        matrix = []
        N = roads * lanes * 2 + (roads + 1) * maxCars

        def createBlock():
            for _ in range(maxCars):
                row = []
                for _ in range(roads):
                    for _ in range(maxCars):
                        row.append("X")
                    for _ in range(lanes * 2):
                        row.append("O")
                for _ in range(maxCars):
                    row.append("X")
                matrix.append(row)


        for _ in range(roads):

            createBlock()

            for _ in range(lanes * 2):
                matrix.append(['O' for _ in range(self.N)])

        createBlock()

        return matrix

    def createSignalMatrix(self):

        signal_grid = [[['X', 'X'] for _ in range(self.N)] for _ in range(self.N)]

        for r in range(self.N - 1):
            for c in range(self.N - 1):

                if 1 == self.h_lanes[r + 1]:

                    if self.v_lanes[c] == 1:
                        signal_grid[r][c] = ["F", "R"]

                    elif self.v_lanes[c] == 2:
                        signal_grid[r][c] = ["LT", "R"]

                elif 4 == self.h_lanes[r - 1]:

                    if self.v_lanes[c] == 3:
                        signal_grid[r][c] = ["LT", "R"]

                    elif self.v_lanes[c] == 4:
                        signal_grid[r][c] = ["F", "R"]

        for r in range(self.N - 1):
            for c in range(self.N - 1):

                if 4 == self.v_lanes[c - 1]:

                    if self.h_lanes[r] == 1:
                        signal_grid[r][c] = ["F", "R"]

                    elif self.h_lanes[r] == 2:
                        signal_grid[r][c] = ["LT", "R"]

                elif 1 == self.v_lanes[c + 1]:

                    if self.h_lanes[r] == 3:
                        signal_grid[r][c] = ["LT", "R"]

                    elif self.h_lanes[r] == 4:
                        signal_grid[r][c] = ["F", "R"]

        for r in range(self.N):
            for c in range(self.N):
                a = (r % (self.lanes * 2 + self.maxCars), c % (self.lanes * 2 + self.maxCars))
                if a[0] >= self.maxCars and a[1] >= self.maxCars:
                    signal_grid[r][c] = [r // (self.lanes * 2 + self.maxCars) + 1, c // (self.lanes * 2 + self.maxCars) + 1]

        return signal_grid

    def displayGrid(self):

        tokens = ["O", "C", "X"]
        augmentedGrid = [[tokens.index(s) for s in r] for r in self.grid]

        fig = plt.figure(figsize=(8,8))
        plt.imshow(augmentedGrid)
        plt.xticks(labels=self.v_lanes, ticks=range(0, self.N))
        plt.yticks(labels=self.h_lanes, ticks=range(0, self.N))

        for i in range(len(self.signal_grid)):
            for j in range(len(self.signal_grid[i])):
                if self.signal_grid[i][j] != ["X", "X"]:
                    text = plt.text(j, i, self.signal_grid[i][j][1],
                                    ha="center", va="center", color="w")

    def spawnCars(self, direction_cars):

        self.grid = self.createMatrix(self.maxCars, self.lanes, self.numRoads)

        for car in direction_cars["N"]:
            self.grid[car.row][car.col] = "C"

        for car in direction_cars["S"]:
            self.grid[car.row][car.col] = "C"

        for car in direction_cars["E"]:
            self.grid[car.row][car.col] = "C"

        for car in direction_cars["W"]:
            self.grid[car.row][car.col] = "C"

    def get(self, r, c):
        self.grid[r][c]

road = RoadGrid(3, 5)
road.displayGrid()
plt.draw()

class Intersection():

    def __init__(self, signals):
        self.signals = signals
        self.changeGroup(1)
        self.green = 1
        self.times = [randint(5, 10) for _ in range(4)]

    def switch(self):
        self.changeGroup(self.green % 4)
        self.green += 1
        self.changeGroup(self.green % 4)

    def changeGroup(self, i):
        for s in self.signals[i]:
            r, c = s
            if road.signal_grid[r][c][1] == "G":
                road.signal_grid[r][c][1] = "R"
            else:
                road.signal_grid[r][c][1] = "G"

ctr = 0
intersections = [[] for _ in range(road.numRoads ** 2)]
for r in range(road.N):
    for c in range(road.N):
        if list(set((road.h_lanes[r], road.v_lanes[c]))) == [2]:
            intersections[ctr] = [[(r-road.lanes, c-(road.lanes-1)), (r+(road.lanes+1), c+road.lanes)],
                                  [(r-road.lanes, c-(road.lanes-2)), (r+(road.lanes+1), c+road.lanes-1)],
                                  [(r+(road.lanes-1), c-road.lanes), (r+(road.lanes-2), c+road.lanes+1)],
                                  [(r+road.lanes, c-road.lanes), (r-(road.lanes-1), c+(road.lanes+1))]]
            ctr += 1

for i in range(len(intersections)):
    intersections[i] = Intersection(intersections[i])

direction_cars = {
    "N" : [],
    "S" : [],
    "E" : [],
    "W" : []
}

deadCars = []

def reset():
    direction_cars = {
        "N" : [],
        "S" : [],
        "E" : [],
        "W" : []
    }
    for i in range(len(deadCars) - 1, -1, -1):
        del deadCars[i]

def sortNorth():
    direction_cars["N"] = sorted(direction_cars["N"], key = lambda c: c.row * 2 + int(c.intention != "M"))

def sortSouth():
    direction_cars["S"] = sorted(direction_cars["S"], key = lambda c: 2 * c.row + int(c.intention == "M"))
    direction_cars["S"].reverse()

def sortEast():
    direction_cars["E"] = sorted(direction_cars["E"], key = lambda c: 2 * c.col + int(c.intention == "M"))
    direction_cars["E"].reverse()

def sortWest():
    direction_cars["W"] = sorted(direction_cars["W"], key = lambda c: c.col * 2 + int(c.intention != "M"))

class Car():

    def __init__(self, startRow, startCol, endRow=0, endCol=0):

        # the current position of the car is saved in col and row (initially startCol and startRow)
        # the target position is stored in endCol and endRow
        self.col = startCol
        self.row = startRow
        self.endCol = endCol
        self.endRow = endRow
        self.movelog = []

        self.v_lane, self.h_lane = self.find_lane()

        # intention: F-Forward LT-Left Turn RT-Right Turn M-Merge
        self.moved = False

        #time a car spends not moving at each intersection
        self.deadTime = [0 for _ in intersections]

        if (self.v_lane == 0):
            if self.h_lane in [3, 4]:
                self.true_dir = "E"
                self.dir = [0, 1]
            else:
                self.true_dir = "W"
                self.dir = [0, -1]

        else:
            if self.v_lane in [3, 4]:
                self.true_dir = "N"
                self.dir = [-1, 0]
            else:
                self.true_dir = "S"
                self.dir = [1, 0]

        self.r_intersection, self.c_intersection = self.find_intersection(self.dir, self.row, self.col)

        endDir = []
        if self.endCol == 0:
            endDir = [0, 1]
        elif self.endRow == 0:
            endDir = [1, 0]
        elif self.endCol == road.N - 1:
            endDir = [0, -1]
        else:
            endDir = [-1, 0]

        self.end_r_intersection, self.end_c_intersection = self.find_intersection(endDir, self.endRow, self.endCol)
        self.intention = "M" if self.mustMerge() else "F"

        direction_cars[self.true_dir].append(self)

    def __eq__(self, o):
        return self.row == o.row and self.col == o.col

    def find_lane(self):
        return (road.v_lanes[self.col], road.h_lanes[self.row])

    def find_intersection(self, dir, row, col):
        try:
            return road.signal_grid[row+dir[0]*road.maxCars][col+dir[1]*road.maxCars]
        except IndexError:
            return [-1,-1]

    def move(self):

        self.moved = False
        jumped_light = False

        if self.intention == "F":
            self.dir, temp_true_dir = self.forward(j=road.signal_grid[self.row][self.col][0] == "F")

        elif self.intention == "LT":
            self.dir, temp_true_dir = self.turnLeft()

        elif self.intention == "RT":
            self.dir, temp_true_dir = self.turnRight()

        elif self.intention == "M":
            self.dir, temp_true_dir = self.merge()

        if self.nextSquareFree(self.dir) and road.signal_grid[self.row][self.col][1] != "R":

            p_row = self.row
            p_col = self.col
            self.row += self.dir[0]
            self.col += self.dir[1]
            road.grid[p_row][p_col], road.grid[self.row][self.col] = road.grid[self.row][self.col], road.grid[p_row][p_col]
            self.v_lane, self.h_lane = self.find_lane()

            if (self.true_dir != temp_true_dir):
                direction_cars[self.true_dir].remove(self)
                direction_cars[temp_true_dir].append(self)

            self.true_dir = temp_true_dir
            self.moved = True

            if abs(self.dir[0]) + abs(self.dir[1]) not in [0, 1] and self.intention!="M":
                jumped_light = True

        else:
            if self.r_intersection not in [-1, "X"]:
                self.deadTime[3 * self.r_intersection + self.c_intersection - 4] += 1

        self.movelog.append([self.intention,jumped_light])
        self.makeNextIntention(jumped_light)

    def makeNextIntention(self, jumped_light):

        dir = self.forward()

        if jumped_light:
            self.r_intersection, self.c_intersection = self.find_intersection(dir[0], self.row, self.col)

        if(self.r_intersection=="X"):
            self.intention="F"

        elif road.signal_grid[self.row][self.col][0] == "LT":
            self.intention = "LT"

        elif road.signal_grid[self.row][self.col][0] == "F":
            self.intention = "RT" if self.mustTurnRight() else "F"

        elif jumped_light and self.mustMerge():
            self.intention = "M"

        else:
            self.intention = "F"

    def nextSquareFree(self, dir):
        #Determine if the square the car will move inot is occupied
        #If it is at the edge destroy it

        if self.intention in ["F", "M"] and (self.row + self.dir[0] in [-1, road.N] or self.col + self.dir[1] in [-1, road.N]):
            self.destroy()
            return False

        if road.grid[self.row + dir[0]][self.col + dir[1]] == "O":
            return True
        else:
            return False

    def forward(self, j=False):
        # j is true if it needs to jump the intersection
        # Determine the vel vector of car to go forward

        if (self.true_dir == "N"):
            dir = [-1, 0]
        elif (self.true_dir == "S"):
            dir = [1, 0]
        elif (self.true_dir == "E"):
            dir = [0, 1]
        else:
            dir = [0, -1]
        return [dir, self.true_dir] if not(j) else [[dir[0] * (road.lanes * 2 + 1), dir[1] * (road.lanes * 2 + 1)], self.true_dir]

    def turnLeft(self):
        # Determine velocity vector to turn left

        if (self.true_dir == "N"):
            dir = [-3, -3]
            temp_new_true_dir = "W"
        elif (self.true_dir == "S"):
            dir = [3, 3]
            temp_new_true_dir = "E"
        elif (self.true_dir == "E"):
            dir = [-3, 3]
            temp_new_true_dir = "N"
        else:
            dir = [3, -3]
            temp_new_true_dir = "S"
        return [dir, temp_new_true_dir]

    def turnRight(self):
        # Determine vel vector to turn right

        if (self.true_dir == "N"):
            dir = [-1, 1]
            temp_new_true_dir = "E"
        elif (self.true_dir == "S"):
            dir = [1, -1]
            temp_new_true_dir = "W"
        elif (self.true_dir == "E"):
            dir = [1, 1]
            temp_new_true_dir = "S"
        else:
            dir = [-1, -1]
            temp_new_true_dir = "N"
        return [dir, temp_new_true_dir]

    def merge(self):

        currentLanes = self.find_lane()

        if (currentLanes[0] == 3 or currentLanes[0] == 2 or currentLanes[1] == 3 or currentLanes[1] == 2):
            if (self.true_dir == "N"):
                dir = [-1, 1]
            elif (self.true_dir == "S"):
                dir = [1, -1]
            elif (self.true_dir == "E"):
                dir = [1, 1]
            else:
                dir = [-1, -1]

        else:
            if (self.true_dir == "N"):
                dir = [-1, -1]
            elif (self.true_dir == "S"):
                dir = [1, 1]
            elif (self.true_dir == "E"):
                dir = [-1, 1]
            else:
                dir = [1, -1]

        return [dir, self.true_dir]

    def destroy(self):
        direction_cars[self.true_dir].remove(self)
        deadCars.append(self)
        return self.deadTime

    def gonePast(self, dir):
        current_distance = abs(self.endRow - self.row) + abs(self.endCol - self.col)
        new_distance = abs(self.endRow - (self.row + dir[0])) + abs(self.endCol - (self.col + dir[1]))
        if new_distance > current_distance:
            return True
        return False

    def mustTurnRight(self):

        if self.true_dir == "N":
            if (self.r_intersection == self.end_r_intersection) and (self.c_intersection < self.end_c_intersection):
                return True
        elif self.true_dir == "S":
            if (self.r_intersection == self.end_r_intersection) and (self.c_intersection > self.end_c_intersection):
                return True
        elif self.true_dir == "E":
            if (self.r_intersection < self.end_r_intersection) and (self.c_intersection == self.end_c_intersection):
                return True
        else:
            if (self.r_intersection > self.end_r_intersection) and (self.c_intersection == self.end_c_intersection):
                return True

        if (self.r_intersection == self.end_r_intersection) and (self.c_intersection == self.end_c_intersection):
            if self.true_dir == "N":
                if self.endCol > self.col:
                    return True
            elif self.true_dir == "S":
                if self.endCol < self.col:
                    return True
            elif self.true_dir == "E":
                if(self.endRow>self.row):
                    return True
            if(self.true_dir=="W"):
                if(self.endRow<self.row):
                    return True

        return False




    def mustTurnLeft(self):
        if self.true_dir == "N":
            if (self.r_intersection == self.end_r_intersection) and (self.c_intersection > self.end_c_intersection):
                return True
        elif self.true_dir == "S":
            if (self.r_intersection == self.end_r_intersection) and (self.c_intersection < self.end_c_intersection):
                return True
        elif self.true_dir == "E":
            if (self.r_intersection > self.end_r_intersection) and (self.c_intersection == self.end_c_intersection):
                return True
        else:
            if (self.r_intersection < self.end_r_intersection) and (self.c_intersection == self.end_c_intersection):
                return True
        if(self.r_intersection==self.end_r_intersection) and (self.c_intersection==self.end_c_intersection):
            if(self.true_dir=="N"):
                if(self.endCol<self.col):
                    return True
            if(self.true_dir=="S"):
                if(self.endCol>self.col):
                    return True
            if(self.true_dir=="E"):
                if(self.endRow<self.row):
                    return True
            if(self.true_dir=="W"):
                if(self.endRow>self.row):
                    return True
        return False


    def mustMerge(self):

        self.v_lane,self.h_lane = self.find_lane()

        if self.true_dir == "N" or self.true_dir == "S":
            if (self.v_lane == 2 or self.v_lane == 3) and self.mustTurnRight():
                return True
            if (self.v_lane == 1 or self.v_lane == 4) and self.mustTurnLeft():
                return True
            if (self.v_lane == 2 or self.v_lane == 3) and (self.end_c_intersection == self.c_intersection):
                return True
            return False

        else:
            if (self.h_lane == 2 or self.h_lane == 3) and self.mustTurnRight():
                return True
            if (self.h_lane == 1 or self.h_lane == 4) and self.mustTurnLeft():
                return True
            if (self.h_lane == 2 or self.h_lane == 3) and (self.end_r_intersection == self.r_intersection):
                return True
            return False

        return False

    def __repr__(self):
        return f"{self.row}, {self.col}, {self.dir}"

def update_all_signals(step):
    for i in intersections:
        if step % i.times[i.green % 4] == 0:
            i.switch()

def update_all_cars():
    # order each list
    # move each car
    # check if each car is deleted

    sortNorth()
    sortSouth()
    sortEast()
    sortWest()

    all_cars = direction_cars["N"] + direction_cars["S"] + direction_cars["W"] + direction_cars["E"]
    for c in all_cars:
        c.move()

def update_cycle_times(n_L):
    for i in range(len(intersections)):
        intersections[i] = n_L[i]

log = []

def step_simulation(step):
    road.spawnCars(direction_cars)
    road.displayGrid()
    plt.draw()
    plt.pause(0.005)
    clear_output(wait=True)
    log.append(direction_cars.copy())
    update_all_cars()
    update_all_signals(step)

def simulate(numCars):

    reset()

    numCarsCurrent = 1
    allLocationsToSpawn = []
    allLocationsToDie = []

    for c in range(road.N):
        if road.v_lanes[c] in [1, 2]:
            allLocationsToSpawn += [[c, road.N - 1]] * c
            allLocationsToSpawn += [[0, c]] * c
            allLocationsToDie += [[c, 0]] * (road.N - c)
            allLocationsToDie += [[road.N - 1, c]] * (road.N - c)
        elif road.v_lanes[c] in [3, 4]:
            allLocationsToSpawn += [[road.N - 1, c]] * c
            allLocationsToSpawn += [[c, 0]] * c
            allLocationsToDie += [[0, c]] * (road.N - c)
            allLocationsToDie += [[c, road.N - 1]] * (road.N - c)

    c1 = Car(31, 7, 6, 0)

    step = 0

    while direction_cars["N"] != [] or direction_cars["S"] != [] or direction_cars["E"] != [] or direction_cars["W"] != []:
        step_simulation(step)
        if numCarsCurrent < numCars:
            l, d = choice(allLocationsToSpawn), choice(allLocationsToDie)
            if road.grid[l[0]][l[1]] == "O":
                a = Car(l[0], l[1], d[0], d[1])
                if a.r_intersection == a.end_r_intersection and a.c_intersection == a.end_c_intersection:
                    a.destroy()
                else:
                    numCarsCurrent += 1
        step += 1

    step_simulation(step)

    sum = np.array([0 for _ in intersections])
    for c in deadCars:
        sum += np.array(c.deadTime)

    #return sum, sum(lambda x: x**0.5, sum)

for _ in range(100):
    simulate(100)

def optimize(L, Li, Lt):
    pass

"""#Our Optimization Process
The signal optimization process was at the center of our project. As we looked at some existing methods, we realized that we would have to design our own.
###A Few Definitions
First we define our *state matrix*, which essentially contains the cycle times of each of the signals at each intersection:
$$\mathbf{L}=\begin{pmatrix}
L_{1, 1}&\cdots & L_{4, 1}\\
\vdots&\ddots&\vdots\\
L_{1, n^2}&\cdots & L_{4, n^2}
\end{pmatrix}$$
At each point in our optimization process, we update our state matrix by adding an *action matrix*. The action matrix is a matrix with the same dimensions as $L$
We define our loss (which our simulation process is designed to minimize) as
$$\mathcal{L}=\sum_{I_i\in I}\sqrt{I_i}$$ where $I$ is the set of times that a car had to stop while approaching intersection $I_i$.
###The Full Algorithm

"""

tree_depth = 10
L = np.array([i.times for i in intersections])

class TreeNode:

    def __init__(self, value, parent=None):
        self.value = value
        self.parent = parent
        self.children = []

    def addChild(self, child):
        self.children.append(child)

    def iter(self, search, start_extrema):
        for child in self.children:
            if child.children == []:
                return self.value == search
            return self.iter(child)

# STEP 1: generating beta matrix (MODEL 2)
def generate_beta_matrix(i):


# STEP 2: filter best four betas based on lowest loss (using output from MODEL 2)
#   RETURN four_b = list of best four betas
def filter_best_four(b, l, i):
    pass

# STEP 3: try four betas on simulation (four_b = list of best four betas from STEP 2)
'''
1.  simulate (add each beta to l and simulate)
'''
def simulate_best_four(four_b):

    model1_training = []
    model2_training = []

    for b in four_b:
        n_beta = np.array(b)
        temp_L = L + n_beta
        update_cycle_times(temp_L)
        I, loss = simulate(100)
        model1_training.append([b, L, I])

    model2_training.append([I, b])

# STEP 4: use previous simulation to train MODEL 1 and MODEL 2 using ONLY the best beta
def train_models(l, b, i, loss):
    pass

# STEP 5: determine best l matrices to continue the process
#   CYCLE BACK TO STEP 1
def propagate(four_loss):
    pass

#direction_cars['E'][0].r_intersection, direction_cars['E'][0].c_intersection
#direction_cars['W'][0].row,direction_cars['W'][0].col
#direction_cars['E'][0].mustMerge()
#direction_cars['E'][0].mustTurnRight()
#direction_cars['E'][0].mustTurnLeft()
#direction_cars['E'][0].h_lane
#direction_cars['E'][0].v_lane
#direction_cars['E'][0].movelog
#direction_cars

np.array([i.times for i in intersections])